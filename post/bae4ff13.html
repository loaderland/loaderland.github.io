<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Redis, keywords">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Redis | LoaderLand</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 7.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="LoaderLand" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">LoaderLand</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">LoaderLand</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://oss.luhuhu.cn/202406051145909.webp')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Redis</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/redis/">
                                <span class="chip bg-color">redis</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/CS/" class="post-category">
                                CS
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-05-20
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2026-02-28
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    15.8k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>[TOC]</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="测试环境的搭建"><a href="#测试环境的搭建" class="headerlink" title="测试环境的搭建"></a>测试环境的搭建</h2><blockquote>
<p>Win11 + WSL Ubuntu + redis7.0.15</p>
</blockquote>
<p><strong>reidis安装</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 更新系统源，安装基础依赖</span>
<span class="token function">sudo</span> apt update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> apt upgrade -y
<span class="token function">sudo</span> apt <span class="token function">install</span> -y <span class="token function">wget</span> curl net-tools
<span class="token comment" spellcheck="true"># 2. 安装 Redis 稳定版APT 官方源）</span>
<span class="token function">sudo</span> apt <span class="token function">install</span> redis-server -y
<span class="token comment" spellcheck="true"># 3. 验证安装查看版本，确认安装成功）</span>
redis-cli --version
</code></pre>
<p><strong>redis.conf配置</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 备份原始配置防止改错回滚）</span>
<span class="token function">sudo</span> <span class="token function">cp</span> /etc/redis/redis.conf /etc/redis/redis.conf.bak

<span class="token comment" spellcheck="true"># 2. 批量修改核心配置无需手动编辑）</span>
<span class="token function">sudo</span> <span class="token function">sed</span> -i <span class="token string">'s/bind 127.0.0.1 -::1/bind 0.0.0.0/g'</span> /etc/redis/redis.conf          <span class="token comment" spellcheck="true"># 允许所有IP访问</span>
<span class="token function">sudo</span> <span class="token function">sed</span> -i <span class="token string">'s/protected-mode yes/protected-mode no/g'</span> /etc/redis/redis.conf      <span class="token comment" spellcheck="true"># 关闭保护模式</span>
<span class="token function">sudo</span> <span class="token function">sed</span> -i <span class="token string">'s/dir \.\//dir \/var\/lib\/redis/g'</span> /etc/redis/redis.conf            <span class="token comment" spellcheck="true"># 数据目录</span>
<span class="token function">sudo</span> <span class="token function">sed</span> -i <span class="token string">'s/# maxmemory &lt;bytes>/maxmemory 256MB/g'</span> /etc/redis/redis.conf       # 内存限制
<span class="token function">sudo</span> <span class="token function">sed</span> -i <span class="token string">'s/# maxmemory-policy noeviction/maxmemory-policy allkeys-lru/g'</span> /etc/redis/redis.conf  # 内存淘汰策略
<span class="token function">sudo</span> <span class="token function">sed</span> -i <span class="token string">'s/daemonize yes/daemonize no/g'</span> /etc/redis/redis.conf                <span class="token comment" spellcheck="true"># 关闭后台运行适配systemd）</span>

<span class="token comment" spellcheck="true"># 3. 修复配置文件+数据目录权限解决WSL权限bug）</span>
<span class="token function">sudo</span> <span class="token function">mkdir</span> -p /var/lib/redis /var/log/redis
<span class="token function">sudo</span> <span class="token function">chown</span> -R redis:redis /etc/redis/redis.conf /var/lib/redis /var/log/redis
<span class="token function">sudo</span> <span class="token function">chmod</span> 644 /etc/redis/redis.conf
<span class="token function">sudo</span> <span class="token function">chmod</span> 770 /var/lib/redis /var/log/redis
</code></pre>
<p><strong>redis.service服务配置</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 备份原始服务配置</span>
<span class="token function">sudo</span> <span class="token function">cp</span> /usr/lib/systemd/system/redis-server.service /usr/lib/systemd/system/redis-server.service.bak

<span class="token comment" spellcheck="true"># 2. 批量修改服务配置解决超时/notify模式bug）</span>
<span class="token function">sudo</span> <span class="token function">sed</span> -i <span class="token string">'s/Type=notify/Type=simple/g'</span> /usr/lib/systemd/system/redis-server.service  <span class="token comment" spellcheck="true"># 替换启动模式</span>
<span class="token function">sudo</span> <span class="token function">sed</span> -i <span class="token string">'/\[Service\]/a TimeoutStartSec=300'</span> /usr/lib/systemd/system/redis-server.service  <span class="token comment" spellcheck="true"># 延长超时时间</span>
<span class="token function">sudo</span> <span class="token function">sed</span> -i <span class="token string">'s/--supervised systemd//g'</span> /usr/lib/systemd/system/redis-server.service  <span class="token comment" spellcheck="true"># 删除WSL不兼容参数</span>
<span class="token function">sudo</span> <span class="token function">sed</span> -i <span class="token string">'s/ExecStart=.*/ExecStart=\/usr\/bin\/redis-server \/etc\/redis\/redis.conf --daemonize no/g'</span> /usr/lib/systemd/system/redis-server.service  <span class="token comment" spellcheck="true"># 统一启动命令</span>

<span class="token comment" spellcheck="true"># 3. 重新加载systemd配置，清除失败状态</span>
<span class="token function">sudo</span> systemctl daemon-reload
<span class="token function">sudo</span> systemctl reset-failed redis-server
</code></pre>
<p><strong>验证</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 启动 Redis 并设置开机自启</span>
<span class="token function">sudo</span> systemctl start redis-server
<span class="token function">sudo</span> systemctl <span class="token function">enable</span> redis-server

<span class="token comment" spellcheck="true"># 2. 验证服务状态显示 active (running) 即为成功）</span>
<span class="token function">sudo</span> systemctl status redis-server

<span class="token comment" spellcheck="true"># 3. 验证 Redis 功能返回 PONG 即为正常）</span>
redis-cli <span class="token function">ping</span>

<span class="token comment" spellcheck="true"># 4. 验证核心配置生效输出对应值即为配置成功）</span>
redis-cli CONFIG GET bind          <span class="token comment" spellcheck="true"># 输出 "0.0.0.0"</span>
redis-cli CONFIG GET maxmemory     <span class="token comment" spellcheck="true"># 输出 "268435456"256MB）</span>
redis-cli CONFIG GET protected-mode <span class="token comment" spellcheck="true"># 输出 "no"</span>

<span class="token comment" spellcheck="true"># 5. 验证端口监听显示 0.0.0.0:6379 即为外网访问生效）</span>
<span class="token function">sudo</span> <span class="token function">netstat</span> -tulpn <span class="token operator">|</span> <span class="token function">grep</span> 6379
</code></pre>
<img src="https://oss.luhuhu.cn/202602280900195.png" alt="image-20260128094447738" style="zoom: 80%;">

<h2 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h2><table>
<thead>
<tr>
<th>场景名称</th>
<th>技术点</th>
<th>缺陷</th>
<th>方案</th>
</tr>
</thead>
<tbody><tr>
<td>缓存热点数据</td>
<td>1. 数据结构：String、Hash<br>2. 核心特性：过期策略、内存淘汰策略<br>3. 命令：<code>SET/GET</code>、<code>HGET/HMSET</code>、<code>EXPIRE</code><br>4. 性能优化：Pipeline、批量操作</td>
<td>1. 缓存穿透<br>2. 缓存击穿<br>3. 缓存雪崩<br>4. 数据一致性问题<br>5. 热key导致节点压力</td>
<td>见<a href="#Redis%E5%BC%82%E5%B8%B8">异常处理</a></td>
</tr>
<tr>
<td>存储Session</td>
<td>1. 数据结构：String(序列化Session)、Hash<br>2. 核心特性：过期策略<br>3. 核心命令：<code>HMSET/HMGETALL</code>、<code>EXPIRE</code>、<code>DEL</code><br>4. 集群特性：RedisCluster保证Session全局可访问</td>
<td>1. 单点故障导致Session不可用<br>2. 序列化/反序列化的性能损耗<br>3. 过期时间内的内存占用<br>4. 集群场景数据分片不均</td>
<td>见<a href="Redis%E9%AB%98%E5%8F%AF%E7%94%A8">高可用</a></td>
</tr>
<tr>
<td>分布式锁</td>
<td>1. <code>SETNX</code>+<code>EXPIRE</code>、<code>DEL</code>、<code>lua</code>脚本<br>2. 进阶：Redis Redlock算法<br>3. 特性：原子性、过期自动释放</td>
<td>1. <code>SETNX</code>+<code>EXPIRE</code>非原子，加锁成功设置过期失败导致死锁<br>2. 主从切换导致锁丢失 <br>3. 锁超时释放<br>4. 不可冲入、不可阻塞</td>
<td>见<a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁</a></td>
</tr>
<tr>
<td>排行榜</td>
<td>1. 数据结构：Sorted Set，score排序<br>2. 核心命令：<code>ZADD</code>、<code>ZRANGE/ZREVEAGE</code>、<code>ZSCORE</code>、<code>ZINCRBY</code>;<br>3. 扩展：Bitmap辅助统计</td>
<td>1. 数据量大情况下SortedSet性能下降<br>2. 实时性要求高，频繁<code>ZADD</code>、<code>ZINCRBY</code>导致redis节点压力大<br>3. 无法直接实现分组排行榜、分页查询<br>4. 分数相同排序不可定制</td>
<td></td>
</tr>
<tr>
<td>简单消息队列</td>
<td>1. 数据结构：List、Stream<br>2. 核心命令：<code>LPUSH/RPOP</code>、<code>BRPOP</code>;<code>XADD</code>、<code>XREADGROUP</code>、<code>XACK</code><br>3. 特性：<code>Pub/Sub</code>，广播模式</td>
<td>1. List队列：消费者宕机未处理消息丢失；不支持重复消费、消费组<br>2. Stream队列：数据挤压导致内存占用过高；消费组配置复杂，运维成本高<br>3. Pub/Sub：无持久化、消费者理线丢失消息</td>
<td><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></td>
</tr>
<tr>
<td>计数/限流</td>
<td>1. 计数核心：String(INCR/DECR)、Hash(HINCRYBY)<br>2. 限流核心：固定窗口(INCR+EXPIRE)、滑动窗口(SortedSet记录时间戳)<br>3. 特性：院子命令保证计数准确</td>
<td>1. 高并发<code>INCR</code>导致节点CPU飙升、计数溢出String最大数值限制<br>2. 固定窗口临界问题、滑动窗口大数据量下SortedSet性能下降<br>3. 计数/限流无持久化，redis宕机数据丢失</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型在底层会根据数据量大小做编码切换</p>
<p><strong>基础类型</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>底层核心</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>基本类型，存文本、数字、二进制</td>
<td>SDS</td>
<td>缓存会话、页面数据、计数器</td>
</tr>
<tr>
<td>Hash</td>
<td>键值对集合，适合存对象</td>
<td>哈希表+ziplist</td>
<td></td>
</tr>
<tr>
<td>List</td>
<td>有序字符串列表，底层双向链表</td>
<td>快速列表quicklist</td>
<td>消息队列</td>
</tr>
<tr>
<td>Set</td>
<td>无序不重复集合，查找去重效率高</td>
<td>哈希表+整数集合</td>
<td>标签等需要去重的集合运算场景</td>
</tr>
<tr>
<td>Zset</td>
<td>类似Set，多一个权重值，底层跳表实现</td>
<td>哈希表+<strong>跳表</strong></td>
<td>排行榜、积分榜</td>
</tr>
</tbody></table>
<p><strong>后续新增的高级类型</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>底层核心</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td>BitMap</td>
<td>位存储，空间利用率极高</td>
<td>SDS</td>
<td>签到等简单标识信息</td>
</tr>
<tr>
<td>HyperLogLog</td>
<td>概率性数据结构，用于估算技术，固定大小</td>
<td>基数估算算法+字符串</td>
<td>网站UV，对精度要求不高但数据量大</td>
</tr>
<tr>
<td>GEO</td>
<td>地理位置信息，支持经纬度存储和空间查询，底层Zset</td>
<td></td>
<td>附近的人、配送距离</td>
</tr>
<tr>
<td>Stream</td>
<td>消息队列专用，比List多两个特性：自动生辰给全局唯一消息ID；相比Pub/Sub可以消息持久话</td>
<td></td>
<td>消息队列</td>
</tr>
</tbody></table>
<p><strong>数据类型的优化：</strong></p>
<ol>
<li>内存紧凑存储，根据<strong>数量大小使用不同的数据结构</strong>；</li>
<li>渐进式rehash：哈希扩容，拆分多次迁移，避免单次rehash阻塞主线程</li>
<li>跳表优化：zset用<a href="#%E8%B7%B3%E8%A1%A8">跳表</a>而非<a href="#%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a></li>
</ol>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>redis的核心是 <strong>单线程事件驱动模型</strong> + <strong>高效内存数据结构</strong> + <strong>按需持久化机制</strong></p>
<ul>
<li><p>单线程</p>
<blockquote>
<p>单线程无并发问题 ，避免了上下文切换、锁竞争的性的性能消耗，保证命令执行的<strong>原子性</strong></p>
<p>单线程下能保证效率的原因<br>所有操作基于<strong>内存</strong>，CPU直接通过总线访问内存，无协议、磁盘定位等开销；<br>核心操作都是O(1)、O(lgN)的高效算法 如哈希、**<a href="#%E8%B7%B3%E8%A1%A8">跳表</a>**；<br>采用非阻塞IO+事件驱动，避免网络、IO等待</p>
</blockquote>
</li>
<li><p>事件驱动模型(Reactor)</p>
<blockquote>
<p>redis将所有操作抽象为事件</p>
<ul>
<li>文件事件：处理套接字的连接、读、写操作，依赖操作系统的<strong>IO多路复用</strong>，避免单线程阻塞</li>
<li>事件事件：处理定时/周期任务</li>
</ul>
<pre class=" language-mermaid"><code class="language-mermaid">graph TD
A[aeEventLoop 事件循环] --> B[文件事件File Event]
A --> C[时间事件Time Event]
B --> D[套接字操作连接读写]
C --> E[定时任务过期键清理持久化]
B --> F[aeFileEvent 事件处理器]
F --> G[aeAcceptHandler处理新连接]
F --> H[aeReadHandler处理读请求]
F --> I[aeWriteHandler处理写响应]
</code></pre>
</blockquote>
</li>
</ul>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><blockquote>
<p>redis核心架构：命令执行是单线程的，写入场景的单线程有很多的有点，但是读取的场景并没有单线程的需求，当某个读请求卡住会因为这个读取而阻塞其他请求，所以我们想要保证单线程执行写入的同时，”多线程”同时监听多个客户端的套接字连接，全程不阻塞其他套接字的处理</p>
<p>多路复用在网络IO层</p>
</blockquote>
<table>
<thead>
<tr>
<th>多路复用函数</th>
<th>操作系统</th>
<th>核心特点</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td>epoll</td>
<td>Linux（2.6 及以上）</td>
<td>事件驱动、高效、支持海量文件描述符（万级以上）</td>
<td>最高（Redis 首选，生产环境主流）</td>
</tr>
<tr>
<td>kqueue</td>
<td>macOS、FreeBSD</td>
<td>功能与 <code>epoll</code> 类似，事件驱动、高效</td>
<td>次高（类 Unix 系统的最优选择）</td>
</tr>
<tr>
<td>select</td>
<td>所有操作系统（兼容性最好）</td>
<td>轮询模式、低效、支持的文件描述符数量有限（默认 1024）</td>
<td>最低（仅用于兼容老旧系统，<strong>不推荐高并发场景</strong></td>
</tr>
</tbody></table>
<p><strong>多路复用相当于队列？将请求排队，先把请求存起来不阻塞他们？</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>Redis多路复用</th>
<th>消息队列</th>
</tr>
</thead>
<tbody><tr>
<td>工作层级</td>
<td><strong>网络 IO 层</strong>（操作系统 / Redis 底层）</td>
<td>业务逻辑层（应用层）</td>
</tr>
<tr>
<td>处理对象</td>
<td>未完成 IO 的请求（数据未传输）</td>
<td>已完成 IO 的请求（数据已到达服务端）</td>
</tr>
<tr>
<td>核心目标</td>
<td>解决单线程 IO 阻塞，提升<strong>连接并发能力</strong></td>
<td>解决业务并发冲突，保证<strong>执行一致性</strong></td>
</tr>
<tr>
<td>排队逻辑</td>
<td>无显式排队，仅处理「就绪的请求」，无序但不阻塞</td>
<td>显式排队，所有请求按序执行，严格串行</td>
</tr>
<tr>
<td>是否产生延迟</td>
<td>几乎无延迟（仅唤醒 / 处理就绪 IO）</td>
<td>有明显延迟（请求入队等待消费）</td>
</tr>
<tr>
<td>一依赖</td>
<td>操作系统原生支持（epoll/kqueue），Redis 封装使用</td>
<td>独立的中间件，需单独部署维护</td>
</tr>
<tr>
<td>与redis关系</td>
<td>Redis<strong>底层核心机制</strong>，必须依赖</td>
<td>与 Redis 无关，是业务层的并发控制方案</td>
</tr>
</tbody></table>
<p>多路复用并不是让请求排队，而是请求IO就绪了自己来找我，<strong>多路复用是不让IO卡线程，消息队列是不让业务卡业务</strong></p>
<p><strong>医院场景示例</strong></p>
<blockquote>
<h3 id="多路复用：医院的「大门分诊台」（网络-IO-层）"><a href="#多路复用：医院的「大门分诊台」（网络-IO-层）" class="headerlink" title="多路复用：医院的「大门分诊台」（网络 IO 层）"></a>多路复用：医院的「大门分诊台」（网络 IO 层）</h3><ul>
<li><strong>工作对象</strong>：刚到医院门口、还没进入诊疗区的病人（还未完成网络 IO 的请求，数据还没传到 Redis）；</li>
<li><strong>核心工作</strong>：判断「哪个病人已经走到分诊台（IO 就绪）」，让他进入诊疗区，<strong>避免工作人员跑到大门口挨个等病人（阻塞 IO）</strong>；</li>
<li><strong>排队逻辑</strong>：病人不用排队，只要走到分诊台（IO 就绪），就会被依次接待，未到的病人不会占用工作人员时间；</li>
<li><strong>核心目的</strong>：让工作人员能高效接待「同时到达的大量病人」，不被某个走得慢的病人堵在大门口。</li>
</ul>
<h3 id="消息队列：医院的「诊疗区叫号机」（业务逻辑层）"><a href="#消息队列：医院的「诊疗区叫号机」（业务逻辑层）" class="headerlink" title="消息队列：医院的「诊疗区叫号机」（业务逻辑层）"></a>消息队列：医院的「诊疗区叫号机」（业务逻辑层）</h3><ul>
<li><strong>工作对象</strong>：已经进入诊疗区、挂完号等待看病的病人（已完成网络 IO，请求已经到达 Redis / 业务服务端）；</li>
<li><strong>核心工作</strong>：让病人按号排队，<strong>避免多个病人同时挤到医生诊室（业务并发冲突）</strong>；</li>
<li><strong>排队逻辑</strong>：病人必须按顺序排队，叫到号才能进入诊室执行业务（看病），全程串行；</li>
<li><strong>核心目的</strong>：让医生能有序处理病人，避免并发冲突，保证业务执行的一致性。</li>
</ul>
<h3 id="二者的配合（如果医院同时有分诊台-叫号机）"><a href="#二者的配合（如果医院同时有分诊台-叫号机）" class="headerlink" title="二者的配合（如果医院同时有分诊台 + 叫号机）"></a>二者的配合（如果医院同时有分诊台 + 叫号机）</h3><p>病人先经过<strong>分诊台（多路复用）</strong> 进入诊疗区，再通过<strong>叫号机（消息队列）</strong> 排队看病，二者分工明确，缺一不可，这也是实际生产中「Redis 多路复用 + 业务层 MQ」的真实配合逻辑。</p>
</blockquote>
<h2 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h2><blockquote>
<p>Reid部署方案的演进，核心是为了解决单点Redis的两个核心问题：</p>
<ul>
<li>可用性问题：单点redis可靠性差，宕机后服务不可用</li>
<li>扩展性问题：单节点的内存QPS瓶颈，无法支撑大规模业务的高并发、大数据量需求</li>
</ul>
</blockquote>
<h3 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h3><p>Redis的持久化核心是将<strong>内存写入磁盘</strong>，宕机时避免数据丢失</p>
<h4 id="RDB快照持久化"><a href="#RDB快照持久化" class="headerlink" title="RDB快照持久化"></a>RDB快照持久化</h4><p><strong>原理</strong></p>
<ol>
<li>主线程<code>fork</code>子进程(写实复制<a href="#COW">COW</a>)，子线程遍历内存数据，形成二进制RDB文件</li>
<li>主线程继续处理请求，修改数据会单独 复制一份副本，不影响子进程快照</li>
</ol>
<p><strong>同步策略：触发</strong></p>
<p>手动<code>save/bgsave</code>、<strong>配置定时策略</strong>、主从复制主节点自动触发</p>
<p><strong>优缺点</strong></p>
<ul>
<li>优点<ol>
<li>文件体积小，相对AOF文件RDB的二进制压缩文件小很多</li>
<li>RDB是数据的完整快照，只需要加载RDB到内存，和AOF相比无需 执行命令重放，恢复速度远快于AOF</li>
<li>快照由子进程完成，父进程只在<code>fork</code>期间短暂阻塞，适合高并发</li>
<li>RDB完整快照适合 定期备份场景、数据归档</li>
</ol>
</li>
<li>缺点<ol>
<li>RDB是定时快照，快照期间宕机会丢失两个快照间隙的数据</li>
<li>fork阻塞问题：当写入数据量大的时候，<code>fork</code>子进程耗时越长，阻塞时间越长，影响redis可用性</li>
</ol>
</li>
</ul>
<blockquote>
<p>RDB因其原理导致只适合用于对恢复速度要求高 ，数据丢失容忍度高的场景。如定时备份、容灾等场景</p>
</blockquote>
<h4 id="AOF追加日志"><a href="#AOF追加日志" class="headerlink" title="AOF追加日志"></a>AOF追加日志</h4><p><strong>原理</strong></p>
<ol>
<li>不保存数据本身，记录所有写命令到AOF文件(类似MySQL binlog的<code>statement</code>模式)，重启时重放AOF存的写命令恢复数据</li>
<li>AOF重写:<code>fork</code>子进程遍历内存数据，生成最终状态命令集，多次INCR合并压缩文件体积</li>
</ol>
<p><strong>核心同步刷盘策略</strong></p>
<ul>
<li>always：每次写命令同步刷盘，最安全性能，IO开销巨大redis性能急剧下降一般用于数据持久性要求极高的场景如金融交易、核心账务数据</li>
<li>everysec：每秒刷盘，平衡性能和可靠性，最多丢掉1s数据</li>
<li>no：由操作系统决定刷盘时机，性能最好，但是可靠性差</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li>优点<ol>
<li>安全性可控，<code>always</code>模式下可以实现数据领丢失，可靠性远高于RDB</li>
<li>数据恢复完整，AOF记录所有写命令，重启时重放可完整恢复数据</li>
<li>文件可读性高：AOF文件是明文redis敏玲，可直接查看，便于排查数据问题</li>
<li>无fork阻塞风险，追加命令时无需<code>fork</code>子进程，仅在AOF重写是fork，对主进程阻塞影响小于 RDB</li>
</ol>
</li>
<li>缺点<ol>
<li>文件体积大，存的是全部命令追加，文件远大于RDB，占用更多磁盘空间(<strong><a href="#AOF%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6">AOF重写机制</a></strong>)</li>
</ol>
</li>
</ul>
<h5 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h5><p>为避免对同一条记录多次SET情况导致AOF文件爆炸，优化出一个AOF重写机制（<strong>默认不开启</strong>，也就是会记录所有SET），最终只保留该数据的最新一条有效SET，丢弃冗余SET.<br>AOF重写机制并不是<strong>修改</strong>原AOF文件，而是生成一份<strong>全新的精简AOF文件</strong>流程如下：</p>
<ol>
<li>Redis主进程<code>fork</code>一个子进程，负责生成新的AOF</li>
<li>子进程遍历Redis中所有key，为每个key生成最终的有效命令，写入新AOF</li>
<li>在子进程中生成新AOF期间，主进程继续处理正常写请求，同时 将这些新的命令追加到<strong>AOF重写缓冲区</strong></li>
<li>子进程完成新AOF文件后，主进程会将AOF重写缓冲区所有命令追加到新AOF中<ol>
<li>最后用新AOF替代旧AOF</li>
</ol>
</li>
</ol>
<p>除此之外AOF重写还有两个重要优化：</p>
<ul>
<li>合并批量命令，如对一个列表执行100次LPUSH，重写会合并成一条LPUSH命令</li>
<li>忽略无效命令：对不存在的key执行DEL或对非列表执行LPUSH等无效 命令会被直接忽略过滤</li>
</ul>
<p><strong>触发方式</strong></p>
<ul>
<li><p>手动触发</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> BGREWRITEAOF
Background append only <span class="token function">file</span> rewriting started
</code></pre>
</li>
<li><p>自动触发<br>修改配置文件，当增长率100%时，redis自动执行<code>BGREWRITEAOF</code></p>
<pre class=" language-xml"><code class="language-xml"># AOF 文件最小重写大小（默认 64MB），小于该大小不会触发重写
auto-aof-rewrite-min-size 64mb

# AOF 文件增长率（默认 100%），即当前 AOF 文件大小 ÷ 上一次重写后的 AOF 文件大小 ≥ 100% 时触发
auto-aof-rewrite-percentage 100
</code></pre>
</li>
</ul>
<h4 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h4><p><strong>绝大多数生产环境优选</strong></p>
<blockquote>
<p>由于RDB和AOF各自的短板，redis4.0版本引入了<strong>混合持久化</strong>，结合RDB和AOF的优点：<br>AOF文件的前半部分是RDB格式的完整快照，后半部分是AOF的增量写命令。</p>
<p>在这种模式下，redis重启先加载RDB格式完整快照恢复大部分数据，再重放AOF格式的增量命令，兼顾了RDB的快速恢复和AOF的数据完整性</p>
</blockquote>
<p><strong>开启混合配置</strong></p>
<pre class=" language-xml"><code class="language-xml"># 先开启 AOF（混合持久化依赖 AOF）
appendonly yes

# 开启混合持久化（Redis 4.0+ 支持，默认 yes，推荐开启）
aof-use-rdb-preamble yes

# 其他配置（沿用 AOF 和 RDB 的核心配置）
appendfsync everysec
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
</code></pre>
<p><strong>核心流程</strong><br>混合持久化的核心是AOF重写成RDB+AOF混合格式的文件</p>
<ol>
<li>Redis 执行 <code>BGREWRITEAOF</code> 命令，主进程 <code>fork()</code> 子进程。</li>
<li>子进程遍历 Redis 内存中的所有数据，将数据以 RDB 格式写入临时文件（前半部分）。</li>
<li>父进程将重写期间接收的写命令，追加到「AOF 重写缓冲区」。</li>
<li>子进程完成 RDB 格式数据写入后，通知父进程。</li>
<li>父进程将「AOF 重写缓冲区」中的命令，以 AOF 格式追加到临时文件末尾（后半部分）。</li>
<li>父进程用临时混合文件替换原有的 AOF 文件，重写完成。</li>
</ol>
<h3 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h3><h4 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h4><blockquote>
<p>主从架构是<strong>最基础</strong>的高可用和数据备份方案，采用一主多从结构，核心是<strong>数据复制</strong>，主节点处理所有请求（也可以做<strong>读写分离</strong>只负责写入），从节点 通过复制主节点数据形成副本，实现数据备份和分担主节点的读压力</p>
<p>纯主从架构中，主节点宕机redis服务会处于可读不可写状态，直到主节点恢复</p>
</blockquote>
<ul>
<li><p>主节点：核心节点，处理所有<code>SET/HSET</code>等命令，同时接受从节点复制请求，同步数据给从节点</p>
</li>
<li><p>从节点：只读节点，仅复制主节点，提供读服务，分担主节点读压力</p>
</li>
</ul>
<p><strong>核心工作流程</strong></p>
<ul>
<li>全量复制(首次同步/大故障后同步)<ol>
<li>从节点向主节点发送同步请求</li>
<li>主节点接收请求后，执行<code>bgsave</code>, <code>fork</code>子进程复制RDB快照 ，同时将快照创建期间接受的写命令缓存到<strong>复制积压缓冲区</strong>（repl_backlog_buffer）</li>
<li>从节点获取到RDB文件，加载RDB文件</li>
<li>主节点将复制积压缓冲区的增量写命令发送给 从节点</li>
<li>从节点执行增量命令</li>
</ol>
</li>
<li>增量同步<br>主节点后续执行的所有写命令都会通过复制积压缓冲区（repl_backlog_buffer），试试发送给从节点<ul>
<li>主节点每执行一个写，就将命令追加到复制积压缓冲区</li>
<li>从节点定期向主节点发送心跳，同时携带同步的偏移量</li>
<li>主节点根据偏移量，将复制积压缓冲区中未同步命令发送给从节点</li>
<li>从节点 执行，保持和主节点的数据一致性，实现增量同步</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>级联复制</strong>，主从复制在一主多从情况下，为了缓解主节点的复制压力，可以让从节点作为其他从节点的复制结点，形成主-&gt;从-&gt;从的链式结构</p>
</blockquote>
<blockquote>
</blockquote>
<h5 id="复制积压缓冲区和AOF的区别"><a href="#复制积压缓冲区和AOF的区别" class="headerlink" title="复制积压缓冲区和AOF的区别"></a>复制积压缓冲区和AOF的区别</h5><p>复制积压缓冲区是专服务于<strong>主从同步</strong>的，AOF是服务于<strong>redis磁盘持久化</strong>的，当开启混合持久化模式时同步依然是走先同步AOF(RDB+AOF)，之后在同步复制积压缓冲区给从库（即便AOF中可能和复制积压缓冲区中有重复的部分），实现同步。</p>
<p><strong>整个同步流程</strong></p>
<blockquote>
<p><strong>阶段 1</strong>：从库发起同步请求，主库初始化同步</p>
<ol>
<li>从库执行<code>slaveof 主库IP 端口</code>，向主库发送<strong>同步请求</strong>，携带自身标识；</li>
<li>主库接收到请求后，标记该从库为「待同步节点」，<strong>初始化复制积压缓冲区</strong>（若未初始化），同时记录「主库运行 ID（runid）」和「当前主库偏移量（master_repl_offset=0）」。</li>
</ol>
<p>阶段 2：主库 fork 子进程，生成「RDB+AOF 混合文件」（全量数据准备）</p>
<ol>
<li>主库执行<code>fork</code>系统调用创建子进程（利用 COW 机制，不阻塞主进程），<strong>子进程负责遍历主库内存全量数据，生成 RDB 二进制快照</strong>；</li>
<li>主进程继续处理客户端写命令，此时会做3 个关键操作（核心：同一份命令多端写入）：<ul>
<li>写入<strong>AOF 缓冲区</strong>（最终刷盘到混合格式的 AOF 文件，持久化落地）；</li>
<li>写入<strong>复制积压缓冲区</strong>（内存环形缓冲区，供主从同步使用）；</li>
<li>写入<strong>复制客户端缓冲区</strong>（实时推送给从库，若从库还未准备好，先暂存）；</li>
</ul>
</li>
<li>子进程生成 RDB 完成后，主库会将<strong>fork 期间主进程产生的所有增量写命令</strong>，以<strong>AOF 明文格式</strong>拼接在 RDB 文件后，生成 **「RDB 全量 + AOF 增量」的混合文件 **（这就是混合持久化的产物，和 AOF 重写的文件格式完全一致）。</li>
</ol>
<p><strong>阶段 3</strong>：主库传输混合文件，从库加载全量数据（全量同步核心）</p>
<ol>
<li><p>主库通过 TCP 长连接，将<strong>混合文件完整传输给从库</strong>；</p>
</li>
<li><p>从库接收混合文件后，</p>
<p>先清空自身内存数据</p>
<p>，执行两步加载：</p>
<ul>
<li>第一步：加载<strong>混合文件的 RDB 部分</strong>，快速恢复主库 fork 瞬间的全量数据（RDB 加载速度远快于纯 AOF）；</li>
<li>第二步：加载<strong>混合文件的 AOF 部分</strong>，重放主库 fork 期间的增量命令，恢复到主库「当前最新数据状态」；</li>
</ul>
</li>
<li><p>加载完成后，从库记录<strong>主库 runid</strong>和<strong>自身偏移量（slave_repl_offset）</strong>，并向主库发送「加载完成确认」。</p>
</li>
</ol>
<p><strong>阶段 4</strong>：进入常态增量同步，依赖复制积压缓冲区（核心阶段，长期运行）</p>
<p>这是主从同步的<strong>常态阶段</strong>，全量同步完成后永久运行，<strong>复制积压缓冲区是核心载体</strong>，AOF 仅做自身持久化，流程如下：</p>
<ol>
<li><p>主库处理客户端</p>
<p>任意写命令</p>
<p>（SET/HSET/DEL 等），执行后做</p>
<p>3 个必选操作：</p>
<ul>
<li>✅ 更新自身内存数据；</li>
<li>✅ 将命令写入<strong>AOF 缓冲区</strong>（按混合格式刷盘，保障主库自身宕机不丢数据）；</li>
<li>✅ 将命令写入<strong>复制积压缓冲区</strong>，同时<strong>主库偏移量（master_repl_offset）自增</strong>（每 1 字节命令 + 1）；</li>
</ul>
</li>
<li><p>主库通过长连接，<strong>将该写命令实时推送给从库</strong>；</p>
</li>
<li><p>从库接收命令后，<strong>立即在本地执行</strong>，更新自身内存数据，同时<strong>从库偏移量（slave_repl_offset）自增</strong>（与主库偏移量保持一致）；</p>
</li>
<li><p>从库以<strong>1 秒为间隔</strong>，向主库发送<strong>心跳包（PING）</strong>，心跳包中携带<strong>自身当前偏移量</strong>；</p>
</li>
<li><p>主库接收心跳包后，</p>
<p>对比主从偏移量：</p>
<ul>
<li>若两者一致：回复 PONG，同步状态正常；</li>
<li>若从库偏移量 &lt; 主库偏移量：说明从库漏同步了命令，主库从<strong>复制积压缓冲区</strong>中提取「从库偏移量→主库偏移量」之间的所有增量命令，推送给从库，从库执行后补全偏移量。</li>
</ul>
</li>
</ol>
<p><strong>阶段 5</strong>：短暂断连后恢复，走「部分重同步」（复制积压缓冲区的核心价值）</p>
<p>若主从网络短暂波动导致断连，<strong>只要复制积压缓冲区未被覆盖</strong>，就不会触发全量同步，流程如下：</p>
<ol>
<li>主从断连期间，主库继续处理写命令，<strong>正常写入 AOF 和复制积压缓冲区</strong>，主库偏移量持续自增；</li>
<li>从库重连主库后，向主库发送<strong>重同步请求</strong>，携带「之前记录的主库 runid」+「自身断连前的偏移量」；</li>
<li>主库验证：<ul>
<li>若<strong>runid 一致</strong>（主库未重启）+ <strong>从库偏移量在复制积压缓冲区的有效范围内</strong>（未被新命令覆盖）：触发<strong>部分重同步</strong>；</li>
</ul>
</li>
<li>主库从复制积压缓冲区中，提取「从库偏移量到当前主库偏移量」的所有增量命令，一次性推送给从库；</li>
<li>从库执行所有增量命令，更新自身偏移量，<strong>快速恢复与主库的偏移量一致</strong>，回到「阶段 4 的常态增量同步」。</li>
</ol>
<p><strong>阶段 6</strong>：极端情况触发「全量重同步」（兜底机制）</p>
<p>若从库断连时间过长，<strong>复制积压缓冲区中的增量命令被新命令覆盖</strong>，或主库重启（runid 变化），主库会拒绝部分重同步，<strong>重新回到阶段 2</strong>，再次生成「RDB+AOF 混合文件」，走全量同步流程，完成后回到阶段 4。</p>
</blockquote>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>复制积压缓冲区</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>核心用途</td>
<td>服务于「<strong>主从增量同步 / 部分重同步</strong>」，仅用于主从之间的数据补全</td>
<td>服务于「Redis 数据持久化」，防止 Redis 宕机后内存数据丢失，用于重启恢复数据</td>
</tr>
<tr>
<td>存储形式</td>
<td>「内存级」环形缓冲区，数据存储在内存中，断电即失</td>
<td>「磁盘级」日志文件，数据存储在磁盘上，断电后数据不会丢失</td>
</tr>
<tr>
<td>存储内容</td>
<td>仅存储「最新的写命令」（二进制格式，精简），仅保留近期命令，用于补全从库同步缺口</td>
<td>（未开启混合持久化）存储「所有写命令」（明文 Redis 命令格式），按执行顺序完整追加，用于完整恢复内存数据</td>
</tr>
<tr>
<td>生命周期</td>
<td>随Redis主进程启动创建，关闭而销毁；<br>环形特性，写满后会覆盖旧命令；<br>从库长期断连，主库会释放对应的缓冲区资源；</td>
<td>随Redis启动(开启AOF)，文件永久保存在磁盘；<br>无限追加；<br></td>
</tr>
<tr>
<td>作用对象</td>
<td>仅作用域主从同步，与客户端无关</td>
<td>仅作用域redis本身,用于redis持久化，与主从架构无关</td>
</tr>
<tr>
<td>配置参数</td>
<td>1. repl-backlog-size:缓冲区大小<br>2.repl-bakclog-ttl：断连后缓冲区保留时间</td>
<td>1. appendonly yes:开启AOF<br>2. appendfsync：刷盘策略<br>3. aotu-aof-rewrite-*:自动重写配置</td>
</tr>
</tbody></table>
<h5 id="增量-全量复制判断逻辑，缓冲区实现原理"><a href="#增量-全量复制判断逻辑，缓冲区实现原理" class="headerlink" title="增量/全量复制判断逻辑，缓冲区实现原理"></a><strong>增量/全量复制判断逻辑，缓冲区实现原理</strong></h5><p>Redis主从复制是根据<strong>复制积压缓冲区</strong>的偏移量来判断<strong>增量复制</strong>和<strong>全量复制</strong>的。</p>
<p><strong>核心结论</strong> </p>
<ol>
<li>增量复制的前提：从节点的偏移量在主节点复制积压缓冲区有效范围内，切主从节点的ID匹配，此时触发<strong>增量复制</strong></li>
<li>全量复制触发场景<ul>
<li>从节点首次复制</li>
<li>主从运行ID不匹配（主节点重启、故障恢复后runid会变更）</li>
<li>从节点的偏移量已不在主节点的复制积压缓冲区（指针被覆盖）</li>
</ul>
</li>
</ol>
<p><strong>复制积压缓冲区原理</strong></p>
<p>复制积压缓冲区的底层是一个<strong>固定大小</strong>的连续字节<strong>环形</strong>数组。</p>
<p>包含数据主体和3个管理标记，3个标记如下</p>
<ul>
<li>主库偏移量，标记主库当前写入进度</li>
<li>起始偏移量，标记缓冲区最久的数据，用于判定增量同步可行性</li>
<li>缓冲区长度，管理环形覆盖逻辑，限定缓冲区最大内存</li>
</ul>
<h5 id="异常场景实例"><a href="#异常场景实例" class="headerlink" title="异常场景实例"></a>异常场景实例</h5><p>纯主从架构，当主节点宕机会发生什么？</p>
<blockquote>
<p>主节点宕机，redis进入 可读不可写状态</p>
<ol>
<li><p>场景一：修复主节点。主节点刷新<strong>runid</strong>，期间从节点会携带两个信息（旧runid和偏移量）持续尝试重连主节点，主节点验证runid不匹配，直接触发<strong>全量复制</strong>。即主从架构 <strong>主节点宕机重启后 所有从节点都会执行一次全量复制</strong> 会造成主节点网络带宽被大量占用(向多个从节点传输RDB快照，可以通过<strong>级联同步规避</strong>)；从节点服务阻塞直到完成同步</p>
</li>
<li><p>场景二：等不了修复了，需要手动选择一个从节点作为新的主节点。<br>为了业务不中断，选择一个从节点作为新的主节点。<br>从节点如何变成主节点：</p>
<ol>
<li><p>选择一个健康、数据同步完整度最高的从节点，解除从节点身份</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 核心命令：取消从节点身份，变为可写主节点</span>
127.0.0.1:6380<span class="token operator">></span> SLAVEOF NO ONE
OK

<span class="token comment" spellcheck="true"># 验证：查看节点角色，确认已变为master（可写）</span>
127.0.0.1:6380<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:master  <span class="token comment" spellcheck="true"># 角色为master</span>
connected_slaves:0  <span class="token comment" spellcheck="true"># 暂无从节点</span>
master_runid:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  <span class="token comment" spellcheck="true"># 新生成的runid（晋升后自动生成）</span>
</code></pre>
</li>
<li><p>逐个登录其他从节点，设置主节点指向</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 核心命令：指向新主节点的IP和端口</span>
127.0.0.1:6381<span class="token operator">></span> SLAVEOF 192.168.1.101 6380  <span class="token comment" spellcheck="true"># 新主节点IP:端口</span>
OK

<span class="token comment" spellcheck="true"># 若新主节点有密码认证，需配置认证密码</span>
127.0.0.1:6381<span class="token operator">></span> CONFIG SET masterauth 123456
OK
</code></pre>
</li>
<li><p>主从全量同步，切换业务读写地址，完成切换</p>
</li>
</ol>
<p>那么当原主节点恢复时会发生什么？</p>
<ol>
<li>原主节点恢复后任然保持主节点和原有数据，形成<strong>双主并存并互不感知的情形</strong></li>
<li>数据必然存在不一致：原主节点宕机前未同步给从节点的偏移量、新主节点在宕机期间接收到的新写入数据，这两部分数据互为缺失，而<strong>Redis无自动合并能力</strong></li>
<li>这种局面会导致业务读写混乱、数据丢失/错乱，<strong>必须人工介入处理</strong></li>
</ol>
<p>处置方式：核心是保留新主节点，将原主节点降级或直接废弃，处置步骤</p>
<ol>
<li>隔离原主节点，防止后续新的写入</li>
<li>处理数据差异：如果原主节点存储的非核心数据可以直接废弃；如果是核心数据就只能通过<strong>人工甄别</strong>迁移到新主节点上(<strong>高危操作</strong>)</li>
<li>原主节点降级或废弃</li>
<li>验证业务状态</li>
</ol>
</li>
</ol>
</blockquote>
<h5 id="主从架构的缺陷"><a href="#主从架构的缺陷" class="headerlink" title="主从架构的缺陷"></a>主从架构的缺陷</h5><ol>
<li>主节点宕机后无自动故障转移，依赖人工介入</li>
<li>主节点宕机恢复后的双主冲突，数据不一致且不具备合并能力</li>
<li>主节点重启或新选举主节点，必然触发全量复制(runid的更新)，引发性能风暴</li>
<li>单主节点性能瓶颈、可靠性健壮性不佳</li>
<li>无统一的节点状态感知监控，各节点的状态(同步进度、偏移量、节点存活)相互独立，无法全局感知管理</li>
</ol>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><blockquote>
<p>哨兵模式是Redis官方提供的企业级高可用方案，基于<strong>主从架构</strong>扩展，核心是 <strong>自动化故障检测和故障转移</strong></p>
</blockquote>
<pre class=" language-mermaid"><code class="language-mermaid">flowchart TB
    subgraph 哨兵集群
    A[sentinel1]---B[sentinel2]
    end
    哨兵集群 ---> 数据节点
    subgraph 数据节点
    C[master] --> D[slave1] --> E[slave2]
    end
    数据节点 --> 客户端
</code></pre>
<p><strong>哨兵节点</strong></p>
<ol>
<li>监控：实时监控数据节点健康状态，定时发送心跳请求</li>
<li>通知：当节点出现故障时候，通过配置的脚本通知运维人员</li>
<li>故障转移：主节点宕机后，自动选举从节点晋升为主节点，更新其他从节点和客户端配置</li>
<li>配置提供者：客户端通过哨兵获取当前主节点地址，无需硬编码主节点IP:PORT</li>
<li>哨兵节点通常部署奇数个，避免选举脑裂，单哨兵存在故障风险</li>
</ol>
<p><strong>启动哨兵节点</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 格式：redis-sentinel &lt;哨兵配置文件路径></span>
redis-sentinel /usr/local/redis/conf/sentinel.conf

<span class="token comment" spellcheck="true"># 或等价于（以哨兵模式启动 Redis）</span>
redis-server /usr/local/redis/conf/sentinel.conf --sentinel
</code></pre>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ul>
<li>监听<ol>
<li>哨兵节点启动后，通过配置文件指定监控的主节点</li>
<li>定期PING，判断主节点存活</li>
<li>主节点超时未响应30s，尚明将主节点标记为<code>主观下线</code></li>
<li>集群哨兵间通信，交换割接点对主节点状态判断</li>
<li>超过半数哨兵判断主观下线，则将主节点标记为<code>客观下线</code>，触发故障转移流程</li>
</ol>
</li>
<li>故障转移<ol>
<li>选举master哨兵：集群 通过Raft选举出<code>master sentinel</code>，仅由MS执行故障转移</li>
<li>选举新主节点：<code>mater sentinel</code>遍历数据节点，根据优先级、复制偏移量、运行规则等，选举 出最优从节点未主节点</li>
<li>晋升主节点：<code>master sentiel</code>向选中的节点发送<code>SLAVEOF NO ONE</code> 晋升为主节点</li>
<li>更新其他从节点：<code>master sentiel</code>向其他数据节点发送<code>SLAVE OF newip:port</code>，设置新主节点（<strong>会全量同步？</strong>）</li>
<li>哨兵集群更新配置将心的主节点作为 后续监控主节点</li>
<li>通知客户端：通过配置脚本通知客户端更新新主节点地址</li>
<li>旧主节点恢复(可选):旧主节点宕机恢复后，会被哨兵自动配置为新主节点的从节点，复制新主节点数据</li>
</ol>
</li>
</ul>
<p><strong>核心配置(sentinel.conf)</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 格式：sentinel monitor &lt;监控名称> &lt;主节点IP> &lt;主节点端口> &lt;法定票数></span>
<span class="token comment" spellcheck="true"># 含义：监控一个名为 mymaster 的主节点，法定票数为 2（需至少 2 个哨兵认为主节点下线，才触发故障转移）</span>
sentinel monitor mymaster 192.168.1.100 6379 2

<span class="token comment" spellcheck="true"># 主节点密码（若主节点有认证，必须配置）</span>
sentinel auth-pass mymaster 123456

<span class="token comment" spellcheck="true"># 主节点主观下线超时时间（默认 30000 毫秒 = 30 秒）</span>
sentinel down-after-milliseconds mymaster 30000

<span class="token comment" spellcheck="true"># 故障转移超时时间（默认 180000 毫秒 = 3 分钟）</span>
sentinel failover-timeout mymaster 180000

<span class="token comment" spellcheck="true"># 故障转移时，同时同步的从节点数量（默认 1，减少对新主节点的压力）</span>
sentinel parallel-syncs mymaster 1

<span class="token comment" spellcheck="true"># 故障通知脚本（可选，节点故障时执行，用于告警）</span>
sentinel notification-script mymaster /usr/local/redis/sentinel/notify.sh
</code></pre>
<h5 id="优劣分析"><a href="#优劣分析" class="headerlink" title="优劣分析"></a>优劣分析</h5><p><strong>优点</strong></p>
<ul>
<li>自动化故障转移</li>
<li>基于主从架构</li>
<li>高可靠：哨兵集群</li>
<li>无需修改客户端配置(硬编码)</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>仅解决了高可用，未解决扩展性，哨兵模式依旧是一主多从，主节点性能瓶颈依然存在</li>
<li>写操作几种在单主节点，无法实现写入的负载均衡</li>
<li>故障转移期间，Redis服务可能有短暂的抖动，对实时性高的业务会有影响</li>
<li>配置和运维复杂度高于 主从架构</li>
</ul>
<h4 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h4><p>RedisCluster是Redis3.0+ 官方提供的<strong>分布式集群方案</strong>，核心是<strong>分片存储</strong>+<strong>分布式高可用</strong></p>
<pre class=" language-mermaid"><code class="language-mermaid">flowchart TB
    subgraph Redis集群
    A[master1:0-5460]---B[master2:5461-10922] --- C[master3:10923-16383]
    A --> D[slave1]
    B --> E[slave2]
    C --> F[slave3]
    end
    Redis集群 --> 客户端
</code></pre>
<p><strong>核心概念</strong><br>集群采用五中心架构，所有节点地位平等</p>
<ul>
<li>槽位：将数据空间划分为16384个槽位，每个键值对通过<code>CRC16(key) % 16384</code>计算，映射到其中一个槽位</li>
<li>主节点与槽位：每个主节点负责一部分槽位</li>
<li>主从节点对应：每个主节点至少配备1个从节点</li>
<li>集群通信：所有结点通过<code>Gossip</code>协议定期交换集群信息(节点状态、槽位分配、故障信息)，保障集群的一致性</li>
</ul>
<p><strong>节点要求</strong></p>
<ul>
<li>集群节点最少为3个主节点+3个从节点</li>
<li>每个节点需开启集群模式</li>
</ul>
<h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><ol>
<li><p>数据分片与存储</p>
<ol>
<li>客户端发送 <code>SET key value</code> 命令，先通过 <code>CRC16(key) % 16384</code> 计算出 <code>key</code> 对应的槽位（如槽位 1000）。</li>
<li>客户端（或节点）查询集群槽位分配信息，找到负责槽位 1000 的主节点（如主节点 1）。</li>
<li>客户端将命令发送到该主节点，主节点执行命令，将数据存储在本地。</li>
<li>主节点将数据同步给自身的从节点，形成数据副本。</li>
</ol>
</li>
<li><p>故障检测与故障转移</p>
<ol>
<li>集群中每个节点定期向其他节点发送 <code>PING</code> 命令，判断节点是否存活。</li>
<li>若某个主节点在超时时间内（默认 15 秒）未返回响应，发送 <code>PING</code> 的节点将其标记为「主观下线」。</li>
<li>若集群中超过半数的主节点都将该主节点标记为「主观下线」，则将其标记为「客观下线」。</li>
<li>该主节点的从节点通过「Raft 算法」选举出一个新主节点，晋升为主节点，接管原主节点的槽位。</li>
<li>集群通过 Gossip 协议更新槽位分配信息，客户端后续请求将发送到新主节点。</li>
</ol>
</li>
<li><p>客户端重定向</p>
<p>若客户端将命令发送到了不负责对应槽位的节点，该节点会返回 <code>MOVED</code> 重定向响应，告知客户端正确的主节点地址，客户端后续将命令发送到正确节点。</p>
</li>
</ol>
<p><strong>核心配置</strong>(redis.conf)</p>
<pre class=" language-conf"><code class="language-conf"># 开启 Redis 集群模式（默认 no，改为 yes）
cluster-enabled yes

# 集群配置文件名称（自动生成，无需手动编辑，记录集群槽位、节点信息等）
cluster-config-file nodes-6379.conf

# 集群节点超时时间（默认 15000 毫秒 = 15 秒，节点超时未响应则标记为下线）
cluster-node-timeout 15000

# 开启持久化（推荐，避免集群重启后数据丢失）
appendonly yes
appendfsync everysec

# 其他基础配置（端口、密码等）
port 6379
requirepass 123456
masterauth 123456
</code></pre>
<p><strong>集群的创建</strong></p>
<p>Redis提供了<code>redis-cli --cluster</code>可快速搭建集群</p>
<ol>
<li><p>准备6个redis节点，分别配置不同端口，开启集群模式</p>
</li>
<li><p>启动6个节点</p>
</li>
<li><p>执行集群搭建命令，自动分配槽位和主从关系</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 格式：redis-cli --cluster create &lt;节点1IP:端口> &lt;节点2IP:端口> ... --cluster-replicas 1</span>
<span class="token comment" spellcheck="true"># --cluster-replicas 1：表示每个主节点对应 1 个从节点</span>
redis-cli --cluster create 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 --cluster-replicas 1 -a 123456
</code></pre>
</li>
<li><p>验证集群状态</p>
<pre class=" language-bash"><code class="language-bash">redis-cli -c -p 6379 -a 123456
127.0.0.1:6379<span class="token operator">></span> CLUSTER INFO  <span class="token comment" spellcheck="true"># 查看集群整体信息</span>
127.0.0.1:6379<span class="token operator">></span> CLUSTER NODES <span class="token comment" spellcheck="true"># 查看集群所有节点信息</span>
</code></pre>
</li>
</ol>
<h5 id="优劣分析-1"><a href="#优劣分析-1" class="headerlink" title="优劣分析"></a>优劣分析</h5><p><strong>优点</strong></p>
<ol>
<li>水平扩展：通过数据分片，将数据分散到多个主节点，增加主节点扩展内存和QPS</li>
<li>分布式高可用：每个节点都有从节点，无需哨兵，主从自行切换</li>
<li>无中心架构：所有结点地位平等，无单点故障风险</li>
<li>支持读写分离：从节点可以提供读服务，分担主节点读压力</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>配置和运维复杂度高：集群的搭建、扩缩容、故障排查难度远高于主从和哨兵</li>
<li>不支持跨槽位操作：跨槽位命令需要客户端拆分命令分别执行</li>
<li>数据迁移有开销：扩缩容期间会占用网络带宽和节点资源，会影响服务性能</li>
<li>不分功能受限：如事务、Lua脚本等在集群模式下有一定限制</li>
</ol>
<h5 id="异常场景"><a href="#异常场景" class="headerlink" title="异常场景"></a>异常场景</h5><ol>
<li><p>因为集群部署是数据分片的，那么范围查询跨分片时会怎么样？如何解决<br>范围查询在单节点内不受影响；<br>范围查询超过单节点会直接失效或额外处理；</p>
<blockquote>
<p>解决方案：</p>
<ol>
<li>使用哈希标签，强制相关key落入同槽位</li>
<li>客户端/<strong>中间件</strong>(Twemproxy、Codis)：分布式场景下通用解决方案，客户端或中间件一次连接集群所有节点，在每个节点上执行<code>SCAN</code>，最后将所有结果聚合返回完整数据</li>
<li>业务侧重新设计数据结构(<strong>业务侧让步</strong>)</li>
</ol>
</blockquote>
</li>
<li><p>如果分片节点和它相关的从节点都故障宕机了，会如何？只是分片主节点宕机 主从切换过程中是不是会丢数据？<br>分片节点和相关的从节点同时故障宕机，会导致该分片相关的所有业务中断，只能人工介入修复；分片节点宕机，主从切换必然会丢失一部分未同步的数据，<strong>复制积压缓冲区原理</strong>中的数据</p>
</li>
</ol>
<p><strong>CRC算法</strong></p>
<h5 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h5><h5 id="读写分离中间件"><a href="#读写分离中间件" class="headerlink" title="读写分离中间件"></a>读写分离中间件</h5><p>Codis、Twemproxy</p>
<p><strong>异地多活</strong></p>
<h5 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h5><p>MinIO、Ceph</p>
<h4 id="云厂商Redis托管"><a href="#云厂商Redis托管" class="headerlink" title="云厂商Redis托管"></a>云厂商Redis托管</h4><p>花钱买服务，相当于把Redis这块业务卖给云厂商，由他们去负责细节的实现，只管使用(<strong>财力雄厚方案</strong>)</p>
<h4 id="心跳模式"><a href="#心跳模式" class="headerlink" title="心跳模式"></a>心跳模式</h4><blockquote>
<p>节点间的心跳是双向、定时的，核心目的是检测<strong>节点的存活</strong> 和 <strong>节点状态/偏移量</strong>，不同架构下的心跳略有差异，单核心一致</p>
</blockquote>
<ol>
<li><p>主从架构下的心跳模式<br>从节点主动发起，主节点被动响应<br>slave -&gt; master，发送PING包，携带3个信息（自身节点ID+已同步的偏移量+主节点runid）<br>master响应，收到PING后返回PONG包(包含主节点当前的偏移量+自身状态)<br>slave接受到PONG后，判断主节点存活，更新自身记录的主节点偏移量，为后续增量同步做准备<br>若PING超时(默认60s)，判定主节点宕机，停止增量同步，进入重连流程</p>
<p>主节点也会主动发送增量数据包，不属于心跳，是数据同步，和心跳并行互不干扰</p>
</li>
<li><p>哨兵模式下的心跳模式<br>哨兵模式的心跳由哨兵节点(sentinel)发起，数据节点(主/从)被动响应，核心是为了监控数据节点的健康状态<br>sentinel -&gt; master/slave，发送PING<br>master/slave 响应PONG(自身状态+是否可读+是否主节点)<br>sentinel在30s内未收到PONG响应，则将该节点标记为主观下线<br>哨兵集群间通过心跳同步节点状态，超过半数哨兵未收到PONG则标记为客观下线，触发故障转移</p>
</li>
</ol>
<p>* </p>
<h2 id="Redis异常"><a href="#Redis异常" class="headerlink" title="Redis异常"></a>Redis异常</h2><h3 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h3><table>
<thead>
<tr>
<th>异常名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>缓存穿透</td>
<td><strong>高危！</strong>通常是恶意攻击。靶数据不存在，缓存、数据库中均没有</td>
</tr>
<tr>
<td>缓存击穿</td>
<td>某热点key过期瞬间，大量请求打到数据库。常见于秒杀、抢车票情形</td>
</tr>
<tr>
<td>缓存雪崩</td>
<td>大批量key同时过期，或redis服务宕机，请求全打到数据库</td>
</tr>
</tbody></table>
<h4 id="缓存穿透、击穿、雪崩的应对策略"><a href="#缓存穿透、击穿、雪崩的应对策略" class="headerlink" title="缓存穿透、击穿、雪崩的应对策略"></a>缓存穿透、击穿、雪崩的应对策略</h4><p><strong>穿透</strong></p>
<ol>
<li><p>入口校验<br>参数和方法性校验，如数据类型、数值大小(ID &lt; 0)等直接返回</p>
</li>
<li><p><strong><a href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">布隆过滤器</a></strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> User <span class="token function">getUser</span><span class="token punctuation">(</span>Long userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String key <span class="token operator">=</span> <span class="token string">"user:"</span> <span class="token operator">+</span> userId<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 1. 先查布隆过滤器</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bloomFilter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token string">"user_bloom"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 布隆过滤器说不存在，直接返回</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 2. 查缓存</span>
    User user <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> user<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 3. 查数据库</span>
    user <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> user<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><p>缓存空值<br>已经打到数据库返回<code>null</code>的数据也在内存中缓存一个空标识，设置较短过期时间，防止同一个不存在的key反复穿透</p>
</li>
</ol>
<p><strong>击穿</strong></p>
<ol>
<li>互斥锁：缓存失效时加锁限制只让一个请求数据库重建缓存，其他请求等待。分布式环境用redis <code>SETNX</code>实现<a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁</a></li>
<li>热点数据定时刷新</li>
</ol>
<p><strong>雪崩</strong></p>
<ol>
<li>大量key同时过期情形：过期时间随机分布，避免集体失效</li>
<li>redis宕机情形<ul>
<li>Redis<a href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88">高可用</a>部署：主从架构+哨兵模式、集群部署</li>
<li>本地缓存：本地缓存<strong>Caffeine/GuavaCache</strong>，转移部分压力到JVM缓存</li>
<li>服务熔断：Sentinel/Hystrix，监听压力过大直接熔断，避免系统崩溃</li>
<li>缓存预热：系统启动主动加载热点数据到缓存，避免冷启动大量请求穿透</li>
</ul>
</li>
</ol>
<h3 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h3><p>双写一致性问题，即不同数源之间同步间隙产生的不一致情形</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器(BloomFilter)是一种<strong>概率型</strong>数据结构，不存在一定，存在不一定。</p>
<p><strong>原理</strong></p>
<blockquote>
<p>布隆过滤器由一个位数组和k个独立的哈希函数组成。添加元素通过k哈希  函数算出k个位置，置1；查询时计算同样k位置，全1则可能存在，存在1个0则一定不存在。<strong>误判发生在不同元素哈希冲突时</strong></p>
<p>布隆过滤器<strong>不支持删除</strong>，只能新增。想要删除某个元素，只能把整个过滤器重建<br>位数组的某个位可能是多个元素共同设置的，导致其中一个删除时会将另一个误判为不存在，所以不支持删除</p>
</blockquote>
<p><strong>适用场景</strong>：大数量，允许小概率误判允许一定的不可靠性），只判断存在性</p>
<ul>
<li>爬虫url去重</li>
<li>垃圾邮件过滤</li>
<li>推荐系统去重</li>
<li>分布式缓存</li>
</ul>
<p><strong>RedisBloom模块详解</strong></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建过滤器时指定误判率和预期容量</span>
BF.RESERVE myfilter 0.001 10000000
<span class="token comment" spellcheck="true"># 误判率 0.1%，容量 1000 万</span>

<span class="token comment" spellcheck="true"># 批量添加</span>
BF.MADD myfilter item1 item2 item3

<span class="token comment" spellcheck="true"># 批量查询</span>
BF.MEXISTS myfilter item1 item2 item3

<span class="token comment" spellcheck="true"># 查看过滤器信息</span>
BF.INFO myfilter
</code></pre>
<p><strong>Java Redisson操作</strong></p>
<pre class=" language-java"><code class="language-java">RBloomFilter<span class="token operator">&lt;</span>String<span class="token operator">></span> bloomFilter <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getBloomFilter</span><span class="token punctuation">(</span><span class="token string">"user_bloom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 初始化，预期插入 5000 万，误判率 3%</span>
bloomFilter<span class="token punctuation">.</span><span class="token function">tryInit</span><span class="token punctuation">(</span>50000000L<span class="token punctuation">,</span> <span class="token number">0.03</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

bloomFilter<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"user:10086"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> exists <span class="token operator">=</span> bloomFilter<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"user:10086"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>误判率和参数选择</strong></p>
<p>误判率取决于三个因素：位数组大小m，哈希函数个数k，已插入元素数量n</p>
<p>理论上最优哈希函数个数 <code>k = (m/n) &amp; ln2</code>，大约是0.7倍的位数组和元素数量之比<br>实际工程中一般这样估算：</p>
<ol>
<li>误判率1%，每个元素约10bit</li>
<li>误判率0.1%，每个元素约15bit</li>
<li>误判率0.01%，每个元素约20bit</li>
</ol>
<p>降低误判率通过增大位数组，增加哈希函数来降低，但是<strong>哈希冲突不可避免</strong>无法降低误判率到0），其实是用<strong>空间换可靠性</strong></p>
<p><strong>布隆过滤器的变种</strong></p>
<ul>
<li>counting bloom fileter：每个位置 不是0/1，而是计数器，可以删除，代价是空间翻好几倍</li>
<li>cuckoo filter：支持删除，空叫效率和原版差不多，Facebook在用</li>
<li>scalable bloom filter：支持动态扩容，元素超了自动加一层过滤</li>
</ul>
<blockquote>
<p>RedisBloom  模块只支持cuckoo filter，用CF.ADD/CF.EXISTS操作</p>
</blockquote>
<p><strong>Redis实现布隆过滤器的方式</strong></p>
<ul>
<li><em>位图手动实现</em> (<strong>不推荐使用，自己实现自己选哈希、计算数组大小、写代码逻辑容易出错)</strong><br><code>SETBIT/GETBIT</code>自己管理哈希函数和<strong>位数组</strong></li>
<li>官方RedisBloom<br>由一个<strong>位数组</strong>和<strong>k个哈希函数</strong>组成</li>
</ul>
<h3 id="倾斜"><a href="#倾斜" class="headerlink" title="倾斜"></a>倾斜</h3><p>数据分布/访问负载不均，导致单点压力过大</p>
<h2 id="分布式锁和消息队列"><a href="#分布式锁和消息队列" class="headerlink" title="分布式锁和消息队列"></a>分布式锁和消息队列</h2><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><blockquote>
<p>多台应用服务器、多Redis节点(集群/主从)下，并发更新缓存需要用<strong>分布式锁</strong>，保证跨应用、跨节点的并发安全 </p>
</blockquote>
<p><strong>基础方案</strong>：SETNX + EXPIRE</p>
<p>分布式锁的基础实现，核心是利用SETNX的原子性，存在<strong>缺陷</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 加锁</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>String lockKey<span class="token punctuation">,</span> String requestId<span class="token punctuation">,</span> <span class="token keyword">int</span> expireSeconds<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1. SETNX 加锁</span>
    Long result <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> requestId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> result <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 2. EXPIRE 设置过期时间，防止死锁（加锁成功后进程宕机，锁无法释放）</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> expireSeconds<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 解锁</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span>String lockKey<span class="token punctuation">,</span> String requestId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 校验请求ID，防止误删其他线程的锁（重要）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>requestId<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 缓存更新逻辑（伪代码）</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateCache</span><span class="token punctuation">(</span>String cacheKey<span class="token punctuation">,</span> Object newData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String lockKey <span class="token operator">=</span> <span class="token string">"lock:"</span> <span class="token operator">+</span> cacheKey<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 锁key与缓存key绑定</span>
    String requestId <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 唯一标识，用于解锁校验</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 尝试加锁，超时时间30秒</span>
        <span class="token keyword">boolean</span> locked <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> requestId<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>locked<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 加锁失败，重试或直接返回（根据业务场景）</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 加锁成功，安全更新缓存</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> newData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 解锁，释放资源</span>
        <span class="token function">unlock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> requestId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>SETNX 和 EXPIRE是两个独立的命令，两者一起运行的时候没有原子性，存在SETNX 加锁成功后服务宕机EXPIRE无法执行，造成死锁</p>
</blockquote>
<p><strong>优化方案</strong> SET key value NX EX，原子加锁</p>
<p>redis支持<code>SET</code>命令组合参数，将加锁和设置 过期时间合并为一个原子命令，解决SETNX 和EXPIRE的缺陷</p>
<pre class=" language-bash"><code class="language-bash">SET lock:user:1001 uuid-12345 NX EX 30
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 原子加锁（推荐）</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLockAtomic</span><span class="token punctuation">(</span>String lockKey<span class="token punctuation">,</span> String requestId<span class="token punctuation">,</span> <span class="token keyword">int</span> expireSeconds<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// setIfAbsent 重载方法，直接实现 NX + EX 原子操作</span>
    Boolean result <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>
        lockKey<span class="token punctuation">,</span> 
        requestId<span class="token punctuation">,</span> 
        expireSeconds<span class="token punctuation">,</span> 
        TimeUnit<span class="token punctuation">.</span>SECONDS
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 避免空指针（RedisTemplate 集群环境下可能返回 null）</span>
    <span class="token keyword">return</span> Boolean<span class="token punctuation">.</span>TRUE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 原子解锁（必须用 Lua 脚本，保证「校验+删除」原子性）</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlockAtomic</span><span class="token punctuation">(</span>String lockKey<span class="token punctuation">,</span> String requestId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String luaScript <span class="token operator">=</span> <span class="token string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span><span class="token punctuation">;</span>
    redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>
        <span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>luaScript<span class="token punctuation">,</span> Long<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        Collections<span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">,</span>
        requestId
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>进阶方案</strong>：Redisson分布式锁</p>
<h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p><strong>Redisson</strong>，封装了完善的分布式锁(可重入、可阻塞、自动续期)，支持单机、集群、哨兵等多种部署模式</p>
<ul>
<li>自动实现了<code>SET NX EX</code>原子加锁 </li>
<li>内置<strong>WatchDog</strong>机制，自动给未执行完的业务续期所时间，避免锁在业务执行期间过期</li>
<li>支持可重入锁、公平锁、读写锁等锁类型</li>
<li>解锁使用<code>Lua</code>脚本，保证原子性</li>
</ul>
<p><strong>示例</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. 注入 RedissonClient（提前配置好连接）</span>
<span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> RedissonClient redissonClient<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 2. 缓存更新加锁逻辑</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateCacheWithRedisson</span><span class="token punctuation">(</span>String cacheKey<span class="token punctuation">,</span> Object newData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String lockKey <span class="token operator">=</span> <span class="token string">"lock:"</span> <span class="token operator">+</span> cacheKey<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 获取可重入锁</span>
    RLock lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 尝试加锁，最多等待10秒，锁自动过期30秒</span>
        <span class="token keyword">boolean</span> locked <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>locked<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"获取分布式锁失败，无法更新缓存"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 加锁成功，安全更新缓存</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> newData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"加锁过程被中断"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 解锁（只有当前线程持有锁时才会释放）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">isHeldByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>分布式锁的兜底</strong>RedLock</p>
<blockquote>
<p><strong>为了解决主从架构中主节点加锁成功后宕机，从节点未同步到锁信息而造成锁丢失的情形，抽象出一层RedLock(多台redis) 专用于 分布式锁的申请、释放</strong></p>
</blockquote>
<p>Redis主从模式，存在主节点加锁后，同步期间宕机导致锁丢失的问题</p>
<ol>
<li>建立多个单独的主节点Redis(<strong>专注于分布式锁，不涉及业务数据，不需要同步</strong>)</li>
<li>加锁时对所有节点发送<code>SET NX EX</code>超过半数成功才认为加锁成功</li>
<li>解锁时发送所有节点发起释放锁命令，超过半数认为删除锁成功</li>
</ol>
<pre class=" language-mermaid"><code class="language-mermaid">graph TD
A[1.业务发起写入请求] --> B[2.客户端向RedLock申请分布式锁]
B --> C[3.超过半数RedLock Redis加锁成功,返回客户端加锁成功]
C --> D[4.执行业务redis写入操作]
D --> E[5.业务写入结束,向RedLock申请释放分布式锁]
E --> F[6.超过半数RedLock redis释放锁成功,返回客户端解锁成功]
</code></pre>
<h4 id="单机场景-本地锁"><a href="#单机场景-本地锁" class="headerlink" title="单机场景(本地锁)"></a>单机场景(本地锁)</h4><p><strong>synchronized/ReentrantLock</strong></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><strong>给我一个选择分布式锁，不选消息队列的理由？</strong></p>
<blockquote>
<p>分布式锁这么繁琐，人生苦短我选MQ！</p>
</blockquote>
<p>分布式锁和消息队列都是并发控制的核心方案，适用场景的核心差异在于请求<strong>是否需要实时执行、能否接受串行化的性能损耗、业务是否试单节点操作</strong></p>
<p><strong>消息队列(MQ)vs分布式锁</strong></p>
<p>在大多数生产环境，<strong>消息队列</strong>的优先级都高于分布式锁，以下环境优先使用MQ：</p>
<ol>
<li>非实时性要求并发更新场景，允许请求有短暂延迟的，如库存扣减、缓存更新、订单状态同步、积分变更</li>
<li>高并发峰值场景，如秒杀、大促、活动引流，需要削峰填谷，避免请求直接打垮redis/MySQL</li>
<li>单节点业务操作，业务操作之恶换手机一个核心资源，串行处理无冲突</li>
<li>需要失败重试，数据可靠性要求高的</li>
</ol>
<p>单体MQ不适合的场景：(<strong>但是我可以联合分布式事务避免原子性问题</strong>)</p>
<ol>
<li>强实时性要求：请求需要立即执行立即返回结果，不允许等待耗时的</li>
<li>多资源组合，涉及多个资源、多个库，如同时更新余额、库存、订单状态，需要通过锁保证操作的原子性</li>
<li>大量查询极少数写入场景，串行会 导致查询延迟过高，影响用户体验</li>
<li>没有MQ部署的轻量化应用(<strong>没有你用个屁</strong>)</li>
</ol>
<table>
<thead>
<tr>
<th>维度</th>
<th>消息队列</th>
<th>分布式锁</th>
</tr>
</thead>
<tbody><tr>
<td>核心思路</td>
<td>排队串行，消除并发竞争</td>
<td>几所互斥，控制并发竞争</td>
</tr>
<tr>
<td>实时性</td>
<td>低，排队等待消费存在延迟</td>
<td>高，拿到锁立即执行，无额外延迟</td>
</tr>
<tr>
<td>性能</td>
<td>串行处理，但消费端<strong>TPS</strong>有限，可以通过消费端分片提升</td>
<td>并行处理，拿到锁的请求同时执行TPS高</td>
</tr>
<tr>
<td>复杂度</td>
<td>简单，生产/消费端简单开发，无需处理锁逻辑</td>
<td>高，需要封装加解锁、处理锁丢失/死锁/续期，RedLock等复杂技术</td>
</tr>
<tr>
<td>适用操作</td>
<td>单业务操作，支持串行处理</td>
<td>多业务组合操作(事务型操作)，需要并行执行业务</td>
</tr>
<tr>
<td>峰值处理</td>
<td>串行处理无惧峰值</td>
<td>高并发情形锁竞争激烈，易导致请求重试/超时</td>
</tr>
<tr>
<td>失败恢复</td>
<td>天然支持(消息持久化、失败重试、死信队列)</td>
<td>徐手动实现(获取锁失败重试、执行失败回滚)</td>
</tr>
<tr>
<td>部署成本</td>
<td>部署 MQ(RocketMQ/Kafka/RabbitMQ)</td>
<td>需部署redis，主从、集群、RedLock等</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<blockquote>
<p>在符合MQ适用场景的前提下，MQ+事务的方案 整体是优于分布式锁方案的，MQ更稳定、更少踩坑、可维护性更强，是生产环境高并发核心业务的优选。如果一定要说一个分布式锁优于MQ+事务的场景，那么就是单纯的查询业务，极少的写入需求场景</p>
</blockquote>
<h4 id="消息队列的缺陷"><a href="#消息队列的缺陷" class="headerlink" title="消息队列的缺陷"></a>消息队列的缺陷</h4><p>消息队列保证<strong>串行执行</strong>，不保证<strong>执行结果的原子性</strong>，原子性保障需要通过<strong>数据库事务、分布式事务</strong>等其他技术实现</p>
<blockquote>
<p><strong>消息队列无法保障执行结果的原子性的原因</strong></p>
<ol>
<li>消息队列只负责投递消息，不负责监督操作执行结果<br>消息队列的职责是：<br>保证消息可靠投递不丢失、不重复；<br>保证消息按顺序被消费串行执行；<br>消息队列不关心消费端的内部操作及执行结果；</li>
<li>多操作原子性，一来底层资源的事务支持，与消息包无关<br>如更新用户余额和扣减库存的两个操作，本质是对数据库的操作，他们的原子性应该有存储的事务机制来保障，与MQ的投递无关<br>如果是同库操作，通过数据库本地事务保障执行的原子性<br>如果是不同库,通过**<a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">分布式事务</a>**保障执行的原子性</li>
<li>消息重试会导致重复执行，破幻原子性<br>MQ的失败重试机制当执行失败时会重新投递消息包<ul>
<li>假设操作1执行成功，操作2执行失败，MQ重新投递消息，会导致操作以被重复执行</li>
<li>即使做了幂等性处理，也只能保证操作1不被重复执行，依然无法解决操作1成功操作2失败的中间状态，无法保障原子性</li>
</ul>
</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>概念</th>
<th>核心含义</th>
<th>保障主体</th>
<th>失败场景</th>
</tr>
</thead>
<tbody><tr>
<td>串行执行</td>
<td>多个操作顺序执行，不被其他请求打断</td>
<td>消息队列</td>
<td>操作1执行成功，操作2执行失败</td>
</tr>
<tr>
<td>原子性</td>
<td>多个操作构成一个整体，要么全部成功要么全部失败</td>
<td><strong>事务</strong></td>
<td>操作1成功，操作2失败回滚操作1</td>
</tr>
</tbody></table>
<h4 id="如何解决消息队列的缺陷-执行一致性问题"><a href="#如何解决消息队列的缺陷-执行一致性问题" class="headerlink" title="如何解决消息队列的缺陷(执行一致性问题)"></a>如何解决消息队列的缺陷(执行一致性问题)</h4><p>MQ+(分布式)事务，兼顾串行化和原子性</p>
<p><strong>场景</strong></p>
<ul>
<li>简单场景(单库)<ol>
<li>把操作1操作2打成一个消息包，发送到MQ</li>
<li>消费端接受消息，开启数据库<strong>本地事务</strong></li>
<li>串行执行操作1、操作2</li>
<li>执行成功COMMIT，向MQ返回ACK，消息处理成功</li>
<li>任意操作失败，回滚事务<code>ROLLBACK</code>，不向MQ返回ACK，MQ会重新投递消息，直到成功或进入<strong>死信</strong></li>
</ol>
</li>
<li>复杂场景(多库)：MQ+分布式事务<ol>
<li>把操作1操作2打成一个消息包，发送到MQ</li>
<li>消费端接收消息，开启<strong>Seata全局事务</strong></li>
<li>串行调用操作1操作2，每个服务内部开启<strong>数据库本地事务</strong></li>
<li>Seata会自动记录操作前快照、操作后快照，实现自动回滚</li>
<li>如果都执行成功，则全局  提交事务，MQ返回ACK</li>
<li>如果任意操作失败，全局回滚 事务，不向MQ返回ACK，等待重新投递直到成功或进入死信</li>
</ol>
</li>
</ul>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>Seata、TCC、SAGA</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h3><p>copy-on-write 写时复制 是Linux系统的一种内存管理机制，Redis深度依赖COW实现 <strong>RDB持久化</strong>、<strong>AOF重写</strong>、<strong>主从复制</strong>等核心功能</p>
<p>COW<strong>核心逻辑</strong>：当多个进程共享同一块内存数据时，只有 当某个进程对数据执行<strong>写入</strong>操作时，才会为该进程复制一份新的内存副本，供其单独修改，未执行写入操作时仍共享内存数据</p>
<p><strong>Linux底层实现</strong></p>
<blockquote>
<p>Linux通过页表、内存也管理内存，COW基于这两个核心结构实现</p>
<ul>
<li>内存共享：父进程创建子进程(如RDB持久化<code>fork</code>子进程)时，系统不会立即复制父进程的所有内存数据，而是父子共享同一套内存，仅在页表中标记内存页为<strong>只读</strong></li>
<li>写时触发：当父进程对共享内存页执行<strong>写入</strong>操作时，系统检测到只读内存被写入，立即为该内存页复制一份新的物理副本，更新父进程页表指向该副本，允许父进程修改副本，而子进程页表仍然指向只读的原始页</li>
<li>独立修改：父子进程后续内存操作相互隔离，子进程始终能访问到<code>fork</code>创建瞬间的原始内存数据，父进程则操作新的内存副本</li>
</ul>
<p>疑问? 那么当父进程写入之后，子进程访问的还是原副本 什么时候会合并？会存在子进程读取到fork之前的数据，新的进程访问到父进程写入完成后的数据 导致两个进程间数据不一致的情况吗</p>
</blockquote>
<h4 id="Redis为什么需要COW"><a href="#Redis为什么需要COW" class="headerlink" title="Redis为什么需要COW"></a><strong>Redis为什么需要COW</strong></h4><p>Redis是单进程单线程内存数据库，所有正常的读写请求都在主进程处理，而<strong>RDB持久化</strong>、<strong>AOF重写</strong>、<strong>主从同步</strong>等操作，需要读取全量内存写入磁盘/同步从库</p>
<p>直接让主进程执行会有以下问题</p>
<ol>
<li>阻塞主进程：全量读、写会导致主进程无法处理正常请求，阻塞业务服务</li>
<li>数据一致性：操作过程中如果主进程修改数据，会导致持久化/同步数据不完整、不一致</li>
</ol>
<p><code>fork</code>子进程+COW机制，解决了阻塞主进程和不一致问题（读快照）</p>
<h4 id="COW的隐患"><a href="#COW的隐患" class="headerlink" title="COW的隐患"></a>COW的隐患</h4><p>高写入场景下，会带来内存占用飙升、磁盘I/O压力增大，是Redis运维中需要关注的重点</p>
<ol>
<li>fork后，redis主进程大量写操作，会 触发大量内存也的COW复制，导致内存占用迅速飙升，内存不足会触发内存Swap，redis性能会急剧下降</li>
<li>fork子进程曹总，本身就会造成短暂阻塞，当redis占用大时，fork操作耗时越长，会短暂阻塞主进程</li>
<li>子进程的磁盘I/O竞争，fork进程持久化/同步时，会 大量读写磁盘，会造成磁盘带宽占用急剧上升，印象redis主进程<strong>AOF追加写</strong>(AOF默认每秒刷盘)，严重甚至会阻塞主进程</li>
</ol>
<p><strong>针对以上隐患的优化</strong></p>
<ul>
<li>系统层面<ol>
<li>关闭透明大表</li>
<li>保证足够的物理内存（预留内存）</li>
<li>降低fork频率</li>
</ol>
</li>
<li>redis层面<ol>
<li>合理设置<code>maxmemory</code>，避免redis内存占用过高</li>
<li>选择核实的内存淘汰策略，高写入场景使用<code>allkeys-lru</code>/<code>volatile-lru</code>等淘汰策略，及时释放无用内存</li>
<li>主从架构优化：关闭主库的RDB/AOF操作，在从库上做持久化操作，主库只负责读写请求</li>
<li>监控fork耗时：监听fork耗时，超过阈值告警</li>
</ol>
</li>
</ul>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>跳表的本质是<strong>多层链表</strong>，底层链表保存所有元素，上层是下层的子表，通过分层索引查找优化。<br>Redis的跳表笔常规的跳表多一个<strong>回退指针</strong>、并且score允许重复</p>
<blockquote>
<p>为了删除节点时可以快速定位 到前驱节点，不需要 重新遍历</p>
</blockquote>
<p><strong>随机层级的概率算法</strong></p>
<blockquote>
<p>层数n: 0.25 ^ (n-1)*0.75</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ZSKIPLIST_MAXLEVEL 32</span>
<span class="token macro property">#<span class="token directive keyword">define</span> ZSKIPLIST_P 0.25</span>

<span class="token keyword">int</span> <span class="token function">zslRandomLevel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> threshold <span class="token operator">=</span> ZSKIPLIST_P<span class="token operator">*</span>RAND_MAX<span class="token punctuation">;</span>
<span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> threshold<span class="token punctuation">)</span>
  level <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span>level<span class="token operator">&lt;</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">)</span> <span class="token operator">?</span> level <span class="token punctuation">:</span> ZSKIPLIST_MAXLEVEL<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</blockquote>
<p><strong>跳表和红黑树的比较</strong></p>
<p>相比较红黑树，多层链表</p>
<ol>
<li>实现更简单</li>
<li>范围查询效率高</li>
<li>并发友好，只需要锁相关节点，红黑树旋转会锁一片节点</li>
<li>内存占用可控，跳表每个节点平均1.33个指针，红黑树每个节点3个指针</li>
</ol>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><img src="https://oss.luhuhu.cn/202602280900175.png" alt="RBTree"></p>
<p>红黑树是<strong>平衡二叉查找树</strong></p>
<blockquote>
<p>二叉查找树<strong>BST</strong></p>
<p>左子树所有节点值 &lt; 根节点值，右侧所有节点值 &gt; 根节点值；</p>
<p>中序遍历可以得到有序序列</p>
<p>理想情况下查询/插入/删除效率O(lgN)，如果插入有序数据则会退化为单链表</p>
</blockquote>
<p>红黑树是一种近似平衡的二叉查找树，不追求绝对平衡（左右树高差不超过1），通过严格颜色规则维护平衡</p>
<p><strong>特性</strong></p>
<ol>
<li>每个节点要么红色要么黑色</li>
<li>根节点必须黑色</li>
<li>所有叶子结点必须黑色</li>
<li>红色结点子结点必须黑色</li>
<li>从任意结点到其他所有叶子结点路径包含的黑色节点数相同</li>
</ol>
<p><strong>核心操作</strong>：自平衡操作</p>
<ul>
<li>旋转：左旋、右旋，调整节点的子树结构，不改变二叉查找树的有序性</li>
<li>变色：修改节点的颜色，满足颜色规则</li>
</ul>
<p><strong>性能</strong></p>
<ul>
<li>查询/插入/删除的平均和最坏时间复杂度均为O(lgN)</li>
<li>旋转操作的次数少，维护成本低于<strong>AVL树</strong></li>
</ul>
<blockquote>
<p>AVL树严格平衡，每个节点维护平衡因子，旋转次数更多，适合查询效率要求极高，吸入操作少的场景(如数据库索引辅助结构)</p>
</blockquote>
<h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><h3 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h3><h2 id="版本演变"><a href="#版本演变" class="headerlink" title="版本演变"></a>版本演变</h2><h3 id="Redis4-0-引入混合持久化"><a href="#Redis4-0-引入混合持久化" class="headerlink" title="Redis4.0 引入混合持久化"></a>Redis4.0 引入混合持久化</h3><p>结合RDB和AOF，RDB存储全量数据，AOF存储增量命令。兼顾RDB的快速回复和AOF的数据完整性</p>
<h3 id="Redis6-0-多线程IO优化"><a href="#Redis6-0-多线程IO优化" class="headerlink" title="Redis6.0+ 多线程IO优化"></a>Redis6.0+ 多线程IO优化</h3><p>核心命令执行仍单线程，仅将<strong>网络读取</strong>和<strong>响应写入</strong>拆分为多线程，解决单线程高并发情形下<strong>网络带宽</strong>的瓶颈</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">LoaderLand</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://loaderland.github.io/post/bae4ff13.html">https://loaderland.github.io/post/bae4ff13.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">LoaderLand</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/redis/">
                                    <span class="chip bg-color">redis</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC81OTMyMy8zNTc4NQ">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/post/f5f9fa9b.html">
                    <div class="card-image">
                        
                        <img src="https://oss.luhuhu.cn/202406051136170.jpeg" class="responsive-img" alt="Docker">
                        
                        <span class="card-title">Docker</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-05-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/CS/" class="post-category">
                                    CS
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/docker/">
                        <span class="chip bg-color">docker</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/post/104c461b.html">
                    <div class="card-image">
                        
                        <img src="https://oss.luhuhu.cn/202406051149842.png" class="responsive-img" alt="Vim">
                        
                        <span class="card-title">Vim</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-05-14
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/CS/" class="post-category">
                                    CS
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Vim/">
                        <span class="chip bg-color">Vim</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="12103553"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='list'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2026</span>
            
            <span id="year">2023</span>
            <a href="/about" target="_blank">LoaderLand</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
            <span id="icp"><img src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="http://beian.miit.gov.cn/" target="_blank">浙ICP备2023053681号-1</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/loaderland" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:669194168@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=669194168" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 669194168" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/loaderland" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/loaderland" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/LoaderLand" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/LoaderLand" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/loaderland/loaderland.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
